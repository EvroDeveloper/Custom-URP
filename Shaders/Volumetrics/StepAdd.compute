//Second froxel pass 
// 	Sebastien Hillaire https://www.slideshare.net/DICEStudio/physically-based-and-unified-volumetric-rendering-in-frostbite/26

#pragma kernel StepAdd
#define EPSILON  1e-8;


#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/VolumeRendering.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"


RWTexture3D<float4> Result;
Texture3D<float4> InLightingTexture;
SamplerState Custom_trilinear_clamp_sampler;
//float HomogeneousMediumDensity;
float extinction;
float StaticMultiplier;
float4 Scattering;

float4x4    LeftEyeMatrix;
float4x4    RightEyeMatrix;

shared float4 _VolumePlaneSettings;
shared float4 _ZBufferParams;
shared float4 _VBufferDistanceEncodingParams;
shared float4 _VBufferDistanceDecodingParams;

//half4 Accumulate(half4 colorAndDensityFront, half4 colorAndDensityBack)
//{
//	half layerDepth = 1;	//layerDepth temp set 
//
//    half transmittance = exp(colorAndDensityBack.w * layerDepth);
//    half4 accumulatedLightAndTransmittance = half4(colorAndDensityFront.xyz + colorAndDensityBack.xyz * (1.0f - transmittance) * colorAndDensityFront.w, colorAndDensityFront.w * transmittance);
//	
//    return accumulatedLightAndTransmittance;
//}

//float GetSliceEyeDepth(float slice, float numberOfSlices) {
//	
//	float zdepth = slice / numberOfSlices; //Pos of current slice in UV space
////z = pow(saturate(uv.z), _DepthPow); // Depth power to adjust the depth dispution of voxels
//	zdepth = zdepth * _VolumePlaneSettings.y / (1 + zdepth * _VolumePlaneSettings.z); //UV to depth //LinearToVaporDeviceDepth
//
//	zdepth = 1.0 / (_ZBufferParams.z * zdepth + _ZBufferParams.w); // VaporDeviceToEyeDepth 
//
//	return zdepth;
//}
//hist, current, distance, extinction
//float4 AccumulateFog(float4 colorAndDensityFront, float4 colorAndDensityBack, float traveledDistance, float extinction)
//{
//
//	float absorbance = traveledDistance * extinction;
//	float transmittance = exp(-absorbance * colorAndDensityBack.w);
//
//	float4 accumulatedLightAndTransmittance = float4(colorAndDensityFront.xyz + colorAndDensityBack.xyz * (1 - transmittance) * colorAndDensityFront.w, (transmittance * colorAndDensityFront.w));
//
//	return accumulatedLightAndTransmittance;
//}
//
//
//void Accumulate(inout float3 AccumulatedColor, float3 currentColor, float distance, float extinction, inout float opticalDepth)
//{
//
//	float absorbance = distance * extinction;
//
//  //float4 blendValue = float4(current, absorbance); //Current slice color & absorbance
//
//	float transmittance = exp(-opticalDepth);
//
//	AccumulatedColor +=   transmittance * currentColor * Scattering.rgb; // * Scattering.rgb ?
//
//	opticalDepth += absorbance ;
//
//}
//
//float GetDepth(float currentSlice, float numberOfSlices) {
//
//	float Z = (currentSlice + 0.5) / numberOfSlices;
//
//	Z =  Z * _VolumePlaneSettings.y / (1 + Z * _VolumePlaneSettings.z); // LinearToVaporDeviceDepth	
//	return 1.0 / (_ZBufferParams.z * Z + _ZBufferParams.w); // VaporDeviceToEyeDepth 
//
//}
//
//float GetWDepth(float currentW) {
//
//
//	float near = _VolumePlaneSettings.x;
//	float far = _VolumePlaneSettings.y;
//
//	float newZ = currentW * _VolumePlaneSettings.y / (1 + currentW * _VolumePlaneSettings.z); // LinearToVaporDeviceDepth	
//
//	float lerped = lerp(near, far, newZ);
//
//	return lerped;
//}




[numthreads(8, 8, 1)]	
void StepAdd(uint3 id : SV_DispatchThreadID)
{
	//Use this to figure out distance between layers
	//float near = _VolumePlaneSettings.x;
	//float far = _VolumePlaneSettings.y;

	// T (A → B) = 𝑒 ^ -({ S [𝐴 - 𝐵]}	𝛽𝑒(𝑥) 𝑑x	)
	//float Absorption = 0.01f; //temp Absorption rate

	float3 whd ; //make floating to avoid interger calulations later. There's likely a better place to do this
	Result.GetDimensions(whd.x, whd.y, whd.z); //TODO: Send this in scrpit instead of getting it here

	float4 accumScatteringTransmittance = float4(0, 0, 0, 1); //used for current slice output

	//Make stereoscopic.
	float4 Stereo_UVWs = float4(id / whd ,1);

	//Shift space to linear. TODO: link to a shared file and add bias
	//Stereo_UVWs.z = Stereo_UVWs.z * _VolumePlaneSettings.y / (1 + Stereo_UVWs.z * _VolumePlaneSettings.z); // LinearToVaporDeviceDepth	

	int EyeID = floor(Stereo_UVWs.x * 2); //Assume left and right eyes

	Stereo_UVWs.x = frac(Stereo_UVWs.x * 2); //Make both eyes have proper UV.x
	
	///Doesn't support android.
	//if (id.x < whd.x / 2) 	{
	//	Stereo_UVWs = mul(LeftEyeMatrix, Stereo_UVWs);
	//}
	//else	{
	//	Stereo_UVWs = mul(RightEyeMatrix, Stereo_UVWs);
	//}

	//Mask matrix transforms per eye
//	Stereo_UVWs = (mul(LeftEyeMatrix, Stereo_UVWs) * (1-EyeID)) + (mul(RightEyeMatrix, Stereo_UVWs) * EyeID);

	Stereo_UVWs.z = DecodeLogarithmicDepthGeneralized(Stereo_UVWs.z, _VBufferDistanceDecodingParams);


	float invDepthNum = 1.0 / whd.z; // used to avoid division

	float previousDepth = DecodeLogarithmicDepthGeneralized(0, _VBufferDistanceDecodingParams);

 //Max unroll. Maybe make this a precompute to optimize further. TODO: Add clamp in scrpit
//#if defined(SHADER_API_MOBILE)
//	[unroll(32)]
//#else
//	[unroll(128)]
//#endif 
	for (float depth = 0.0; depth < whd.z; depth++) {

		float UVSlice = depth * invDepthNum; // slice / slicecount

		//Sampling the input texture here instead of doing an ID lookup because we are offsetting the UVs to get stereo instead of doing it the previous step
		//TODO: remove extinction multiplication here and do it in previous step
		float4 scatteringExtinction = 
			InLightingTexture.SampleLevel(Custom_trilinear_clamp_sampler,float3(Stereo_UVWs.xy, depth * invDepthNum), 0) * extinction * StaticMultiplier; //Sample current Layer 
		//float zDepth = GetWDepth(UVSlice);
		float zDepth = DecodeLogarithmicDepthGeneralized(UVSlice, _VBufferDistanceDecodingParams);
		float travelDis = zDepth - previousDepth; //Distance between layers


		 float transmittance = exp(-extinction * travelDis );

		accumScatteringTransmittance.rgb += scatteringExtinction.rgb * accumScatteringTransmittance.a;
		//accumScatteringTransmittance.rgb += scatteringExtinction.rgb * accumScatteringTransmittance.a * ((1.0 - transmittance) / extinction);
		accumScatteringTransmittance.a *= transmittance;


	//	float mods = floor(fmod(depth, 2));
	//	Result[int3(id.x, id.y, depth)] = float4(mods.rrr, 1);
	//	Result[int3(id.x, id.y, depth)] = float4(scatteringExtinction.rgb,0);
	//	Result[int3(id.x, id.y, depth)] = frac(float4(Stereo_UVWs.xy, depth / whd.z,0));
	//	Result[int3(id.x, id.y, depth)] = float4( float3(Stereo_UVWs.xy, depth / whd.z) - float3(scatteringExtinction.rgb) ,0);
	//	Result[int3(id.x, id.y, depth)] = InLightingTexture[int3(id.x, id.y, depth)];
	//	Result[int3(id.x, id.y, depth)] = float4(mods.rrr, .25);
	//	Result[int3(id.x, id.y, depth)] = float4(UVSlice, UVSlice, UVSlice, 1-(travelDis / 50));

	//	 Result[int3(id.x, id.y, depth)] = float4(accumScatteringTransmittance.rgb, 1-opticalDepth);


		Result[int3(id.x, id.y, depth)] = accumScatteringTransmittance;

		 previousDepth = zDepth;
	}

}